int time_read() {
    int time = 0;
    if (syscall_read_dev((u_int) & time, 0x15000000, 4) < 0)
        user_panic("time_read panic");
    if (syscall_read_dev((u_int) & time, 0x15000010, 4) < 0)
        user_panic("time_read panic");
    return time;
}

void raid0_write(u_int secno, void *src, u_int nsecs) {
    int i;
    for (i = secno; i < secno + nsecs; i++) {
        if (i % 2 == 0) {
            ide_write(1, i / 2, src + (i - secno) * 0x200, 1);
        } else {
            ide_write(2, i / 2, src + (i - secno) * 0x200, 1);
        }
    }
}

void raid0_read(u_int secno, void *dst, u_int nsecs) {
    int i;
    for (i = secno; i < secno + nsecs; i++) {
        if (i % 2 == 0) {
            ide_read(1, i / 2, dst + (i - secno) * 0x200, 1);
        } else {
            ide_read(2, i / 2, dst + (i - secno) * 0x200, 1);
        }
    }



    获取时间函数time_read
函数原型： int time_read()
函数描述：使用已有的 syscall_read_dev 和 syscall_write_dev 系统调用，对
时钟设备相关地址进行读写，获取当前的UNIX标准时间并作为返回值返回。
Offset Effect
0x0000 Read or Write: Trigger a clock update (a gettimeofday() on the host).
0x0010 Read: Seconds since 1st January 1970
Gxemul Real-Time Clock 映射如下表：(Physical Address: 0x15000000)
1. UNIX标准时间是1970年1月1日至今的时间，单位为秒，是一个十位整
数，前三位数为165
2. 如果获取的时间始终为0，请先通过读写触发时钟更新
git checkout lab5
git add .
git commit --allow-empty -m "save my lab5"
git checkout -b lab5-1-exam
1
2
3
4
第二部分：简易磁盘阵列
我们希望你能实现对一个简易磁盘阵列的读写操作。该磁盘阵列类似于Raid 0，包含2个磁
盘，数据以扇区为单位按序存储在两块磁盘上。(对于如何挂载多块磁盘镜像，见本地测
试部分）
具体需要实现的函数如下：
磁盘阵列写入函数raid0_write
函数原型： void raid0_write(u_int secno, void *src, u_int nsecs)
参数含义：
secno 起始扇区号， *src 数据来源首地址， nsecs 写入的总扇区个数。
即：待写入的扇区范围为 [secno, secno+nsecs) ，扇区范围对应的数据源
地址范围为 [src, src+nsecs*0x200)
函数描述：写入数据时，将扇区号为偶数（2k）的数据写入1号磁盘的k号扇区，将
扇区号为奇数（2k+1）的数据写入2号磁盘的k号扇区。
你可以使用 ide_write ，每次向其中一个磁盘写入一个扇区的数据。
磁盘阵列读取函数raid0_read
函数原型： void raid0_read(u_int secno, void *dst, u_int nsecs)
参数含义：
secno 起始扇区号， *dst 数据目标首地址， nsecs 读取的总扇区个数。
即：待读取的扇区范围为 [secno, secno+nsecs) ，扇区范围对应的数据目
标地址范围为 [dst, dst+nsecs*0x200)
函数描述：在读取数据时，如果待读取数据的扇区号为偶数（2k），则读取1号磁盘
的k号扇区，如果待读取数据的扇区号为奇数（2k+1），则读取2号磁盘的k号扇区。
（写入过程的逆过程）
你可以使用 ide_read ，每次从其中一个磁盘读出一个扇区的数据。








#define MAXL (128)

int raid4_write(u_int blockno, void *src) {
    int i;
    int invalid = 0;
    int check[MAXL];
    for (i = 0; i < 8; i++) {
        if (raid4_valid(i % 4 + 1)) {
            ide_write(i % 4 + 1, 2 * blockno + i / 4, src + i * 0x200, 1);
        } else { invalid++; }
    }
    if (!raid4_valid(5)) {
        return invalid / 2 + 1;
    }
    int j, k;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < MAXL; j++) {
            check[j] = 0;
            for (k = 0; k < 4; k++) {
                check[j] ^= *(int *) (src + (4 * i + k) * 0x200 + j * 4);
            }
        }
        ide_write(5, 2 * blockno + i, (void *) check, 1);
    }
    return invalid / 2;
}

int raid4_read(u_int blockno, void *dst) {
    int i;
    int invalid = 0;
    int wrong = 0;
    int check[2 * MAXL];
    for (i = 1; i <= 5; i++) {
        if (!raid4_valid(i)) {
            invalid++;
            wrong = i;
        }
    }
    if (invalid > 1) {
        return invalid;
    }
    for (i = 0; i < 8; i++) {
        if (i % 4 + 1 != wrong) {
            ide_read(i % 4 + 1, 2 * blockno + i / 4, dst + i * 0x200, 1);
        }
    }
    if (wrong == 5) {
        return 1;
    }
    int j, k;
    ide_read(5, 2 * blockno, check, 2);
    for (i = 0; i < 2; i++) {
        for (j = 0; j < MAXL; j++) {
            for (k = 0; k < 4; k++) {
                check[i * MAXL + j] ^= *(int *) (dst + (4 * i + k) * 0x200 + j * 4);
            }
        }
    }
    if (!wrong) {
        for (j = 0; j < 2 * MAXL; j++) {
            if (check[j] != 0) {
                return -1;
            }
        }
        return 0;
    }
    wrong--;
    user_bcopy(check, dst + wrong * 0x200, 0x200);
    user_bcopy((void *) check + 0x200, dst + 0x800 + wrong * 0x200, 0x200);
    return 1;
}